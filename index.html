<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Bug Squish Dungeon</title>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    background-color: #222;
    color: #eee;
    margin: 0;
    padding: 0;
  }
  /* for preloading images */
  body::after{
   position:absolute; width:0; height:0; overflow:hidden; z-index:-1; // hide images
   content:url(hero_r.png) url(hero_l.png) url(hero_u.png) url(hero_d.png) url(squish.png);   // load images
  }
  h1 { margin: 10px; }
  #game-container {
    display: grid;
    margin: 20px auto;
    gap: 0;
    touch-action: manipulation;
    padding: 10px;
    position: relative;
  }
  .tile {
    width: 80px;
    height: 80px;
    position: relative;
    background-size: cover;
    box-sizing: border-box;
    background-color: #3a3a3a;
  }
  .start { background-image: url('stone.png'); }
  .bug { background-image: url('bug.png'); }
  .squished { background-image: url('squish.png'); }
  .exit { background-image: url('door.png'); }

  /* Hero */
  .hero {
    position: absolute;
    width: 50px;
    height: 50px;
    background-size: cover;
    transition: transform 0.3s ease, top 0.3s ease, left 0.3s ease;
    z-index: 10;
  }


  .hero.right {
    background-image: url('hero_r.png');
  }
  .hero.left {
    background-image: url('hero_l.png');
  }
  .hero.up {
    background-image: url('hero_u.png');
  }
  .hero.down {
    background-image: url('hero_d.png');
  }

  .hero.jump {
    transform: scale(1.3);
  }

  .visited {
    filter: brightness(50%);
  }

  button {
    background-color: #3a3a3a; /* Dark gray base */
    color: #ffffff; /* White text */
    border: 2px solid #39ff14; /* Neon green border */
    border-radius: 8px; /* Rounded corners */
    padding: 10px 20px;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
  }


  button:hover {
    background-color: #2f2f2f; /* Slightly darker on hover */
    color: #39ff14; /* Neon green text on hover */
    box-shadow: 0 0 10px #39ff14; /* Glow effect */
  }



  /* Mobile controls */
  /* Mobile controls */
  #mobile-controls {
      display: none;
      position: relative;
      width: 150px;
      height: 150px;
      margin-top: 30px;
      left: 50%;
      transform: translate(-50%, 0);
  }

  .arrow {
      width: 50px;
      height: 50px;
      background-color: #3a3a3a;
      border: 2px solid #39ff14;
      border-radius: 8px;
      position: absolute;
      cursor: pointer;
  }

  .arrow::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 0;
      border-style: solid;
  }

  .arrow.up::before {
      border-width: 0 15px 25px 15px;
      border-color: transparent transparent #39ff14 transparent;
  }

  .arrow.down::before {
      border-width: 25px 15px 0 15px;
      border-color: #39ff14 transparent transparent transparent;
  }

  .arrow.left::before {
      border-width: 15px 25px 15px 0;
      border-color: transparent #39ff14 transparent transparent;
  }

  .arrow.right::before {
      border-width: 15px 0 15px 25px;
      border-color: transparent transparent transparent #39ff14;
  }

  /* Position arrows on rotated square corners */
  .arrow.up { top: 0; left: 50%; transform: translate(-50%, 0); }
  .arrow.down { bottom: 0; left: 50%; transform: translate(-50%, 0); }
  .arrow.left { left: 0; top: 50%; transform: translate(0, -50%); }
  .arrow.right { right: 0; top: 50%; transform: translate(0, -50%); }

  @media (max-width: 600px) {
      #mobile-controls {
          display: block;
      }
  }


</style>
</head>
<body>
<h1>Bug Squish Dungeon</h1>
<p>Squish all the bugs and go to the exit. You can visit a tile only once.</p>
<div id="buttons">
  <button onclick="resetGame()">Reset Level</button>
</div>
<div id="game-container"></div>
<div id="mobile-controls">
  <button class="arrow up" onclick="move(0, -1)"></button>
  <button class="arrow left" onclick="move(-1, 0)"></button>
  <button class="arrow right" onclick="move(1, 0)"></button>
  <button class="arrow down" onclick="move(0, 1)"></button>
</div>

<script>

function getLevelFromURL() {
    const params = new URLSearchParams(window.location.search);
    const level = parseInt(params.get('level')) || 1;
    return level;
}


const n = getLevelFromURL()+2;
const container = document.getElementById('game-container');
container.style.width = `${80*n}px`;
container.style.gridTemplateColumns = `repeat(${n}, 80px)`;

let grid = [];
let visited = new Set();
let current = { x: 0, y: 0 };
let heroElement;

function createGrid() {
  container.innerHTML = '';
  grid = [];
  for (let y = 0; y < n; y++) {
    for (let x = 0; x < n; x++) {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      if (x === 0 && y === 0) tile.classList.add('start');
      else if (x === n - 1 && y === n - 1) tile.classList.add('exit');
      else tile.classList.add('bug');
      tile.dataset.x = x;
      tile.dataset.y = y;

      container.appendChild(tile);
      grid.push(tile);
    }
  }
  addHero();
  markCurrentTile(current.x, current.y);
}

function addHero() {
  heroElement = document.createElement('div');
  heroElement.classList.add('hero');
  heroElement.classList.add('right');
  container.appendChild(heroElement);
  positionHero(current.x, current.y);
}

function positionHero(x, y) {
  const tileSize = 80;
  heroElement.style.top = `${y * tileSize + 30}px`;
  heroElement.style.left = `${x * tileSize + 25}px`;
}

function getTile(x, y) {
  return grid.find(t => parseInt(t.dataset.x) === x && parseInt(t.dataset.y) === y);
}

function markCurrentTile(x, y) {
  grid.forEach(tile => tile.classList.remove('current_tile'));
  const tile = getTile(x, y);
  tile.classList.add('current_tile');

  // Squish bug if present
  if (tile.classList.contains('bug')) {
    tile.classList.remove('bug');
    tile.classList.add('squished');
  }
}

function move(dx, dy) {
  const nx = current.x + dx;
  const ny = current.y + dy;

  // Rotate hero based on direction
  //heroElement.style.transform = `rotate(${angle}deg)`;
  heroElement.classList.remove('right');
  heroElement.classList.remove('left');
  heroElement.classList.remove('up');
  heroElement.classList.remove('down');
  if (dx === 1) heroElement.classList.add('right');      // Right
  else if (dx === -1) heroElement.classList.add('left'); // Left
  else if (dy === 1) heroElement.classList.add('down');  // Down
  else if (dy === -1) heroElement.classList.add('up');   // Up

  heroElement.classList.add('jump');
  setTimeout(() => {
    heroElement.classList.remove('jump')
    markCurrentTile(nx, ny);
  }, 200);


  if (nx >= 0 && nx < n && ny >= 0 && ny < n && !(nx === 0 && ny === 0) && !visited.has(`${nx},${ny}`)) {
    // Mark old tile as visited
    const oldTile = getTile(current.x, current.y);
    oldTile.classList.remove('current_tile');
    oldTile.classList.add('visited');
    visited.add(`${current.x},${current.y}`);

    current = { x: nx, y: ny };
    positionHero(nx, ny);
    checkWin();


  }
}

function checkWin() {
  if (visited.size === n * n - 1 && current.x === n - 1 && current.y === n - 1) {
    const nextLevelBtn = document.createElement('button');
    const nextLevel = n - 1;
    nextLevelBtn.id = "btn_nextLevel";
    nextLevelBtn.textContent = 'Go to Next Level';
    nextLevelBtn.onclick = function() {
        window.location.search = '?level=' + nextLevel;
    };
    document.getElementById('buttons').appendChild(nextLevelBtn);
  }
}

function resetGame() {
  visited.clear();
  current = { x: 0, y: 0 };
  createGrid();
  const elementToRemove = document.getElementById('btn_nextLevel');
  if (elementToRemove) {
      elementToRemove.remove();
  }
}

document.addEventListener('keydown', e => {
  if (e.key === 'ArrowUp') move(0, -1);
  if (e.key === 'ArrowDown') move(0, 1);
  if (e.key === 'ArrowLeft') move(-1, 0);
  if (e.key === 'ArrowRight') move(1, 0);
});

container.addEventListener('click', e => {
  const tile = e.target.closest('.tile');
  if (!tile) return;
  const x = parseInt(tile.dataset.x);
  const y = parseInt(tile.dataset.y);
  if (Math.abs(x - current.x) + Math.abs(y - current.y) === 1) {
    move(x - current.x, y - current.y);
  }
});

createGrid();
</script>
</body>
</html>
